# Copyright 2004-present Facebook. All Rights Reserved.

from __future__ import print_function

import argparse
import json
import os
import sys
import time

from urllib import urlencode
from urllib2 import urlopen
from urlparse import urlunparse

RELATED_MALWARE ='/malware_analyses' 

def get_app_creds():
    """Reads your App ID and App Secret from env variables"""
    if 'TX_APP_ID' not in os.environ or 'TX_APP_SECRET' not in os.environ:
        print('Please export TX_APP_ID and TX_APP_SECRET'\
            ' in your environment variables')
        sys.exit(-1)
    return {
        'AppID' : os.environ['TX_APP_ID'],
        'AppSecret' : os.environ['TX_APP_SECRET'],
    }

def get_parser():
    parser = argparse.ArgumentParser(
        description='Query ThreatExchange for malware samples from indicators'
    )
    # sample type?
    parser.add_argument('-i', '--input')
    parser.add_argument('-p', '--inputlist')
    parser.add_argument('-f', '--format', default='json')
    parser.add_argument('-c', '--hash', default='sha256')
    parser.add_argument('-s', '--since')
    parser.add_argument('-u', '--until')
    return parser

def get_query(creds, family_id, cursor):
    access_token = '%s|%s' % (creds['AppID'], creds['AppSecret'])
    query_items = {'access_token': access_token}
    if cursor is not None:
        query_items['after'] = cursor
    query = urlencode(query_items)
    return urlunparse((
        'https',
        'graph.facebook.com',
        '/' + str(family_id) + RELATED_MALWARE,
        '',
        query,
        ''
    ))

def run_query(url):
    try:
        # 'data' is a list of objects
        # 'paging' 'cursors' 'after' is an index for moving forward
        resp = json.loads(urlopen(url).read())
    except Exception as e:
        print('Failed to load %s %s' % (url, str(e)))
        return (None, None)
    if len(resp['data']) == 0:
        return (None, None)
    return (resp['data'], resp['paging']['cursors']['after'])

def process_results(curlist, hashname, objs):
    extract_hash = lambda obj: obj[hashname]
    return curlist + map(extract_hash, objs)

def main(query_ids, out_format, hash_name):
  start = int(time.time())
  output = {}
  for indicator_id in query_ids:
      cursor = None
      output[indicator_id] = []
      while True:  # quits once fetched cursor becomes None
          url = get_query(creds, indicator_id, cursor)
          results = run_query(url)
          cursor = results[1]
          if cursor is None:
              break
          output[indicator_id] = process_results(
              output[indicator_id],
              hash_name,
              results[0]
          )
  end = int(time.time())
  if out_format == 'json':
      print(json.dumps(output))
  elif out_format == 'tsv':
      for indicator_id in output:
          for hash_value in output[indicator_id]:
              print('%s\t%s' % (indicator_id, hash_value))
  else:
      print('%s not supported output format' % out_format)
  if len(query_ids) > 1:
      print('Total time elapsed: %d seconds' % (end - start))

if __name__ == '__main__':
    creds = get_app_creds()
    args = get_parser().parse_args()
    # inputs
    if args.input is None and args.inputlist is None:
        print('Input list or input file is needed')
        sys.exit(-1)
    elif args.input is not None and args.inputlist is not None:
        print('Can only take hex hash or input file')
        sys.exit(-1)
    elif args.input is not None:
        query_ids = []
        for line in open(args.input, 'r'):
            # TODO verify line.strip() is a uint64
            query_ids.append(line.strip())
    elif args.inputlist is not None:
        query_ids = set(map(int, args.inputlist.split(',')))
    # time based query
    if args.since is not None:
        print('--since not yet implemented')
        sys.exit(-1)
    if args.until is not None:
        print('--until not yet implemented')
        sys.exit(-1)
    main(query_ids, args.format, args.hash)
